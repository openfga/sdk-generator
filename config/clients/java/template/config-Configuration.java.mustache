{{>licenseInfo}}
package {{invokerPackage}};

import static dev.openfga.util.StringUtil.isNullOrWhitespace;

import dev.openfga.errors.FgaInvalidParameterException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpConnectTimeoutException;
import java.net.http.HttpRequest;
import java.time.Duration;
import java.util.regex.Pattern;

/**
 * Configurations for an ApiClient.
 */
public class Configuration implements BaseConfiguration {
    public static final String VERSION = "0.1";

    private static final String DEFAULT_USER_AGENT = "{{{userAgent}}}";
    private static final Duration DEFAULT_READ_TIMEOUT = Duration.ofSeconds(10);
    private static final Duration DEFAULT_CONNECT_TIMEOUT = Duration.ofSeconds(10);

    private String apiUrl;
    private String userAgent;
    private Duration readTimeout;
    private Duration connectTimeout;

    public Configuration(String apiUrl) {
        this.apiUrl = apiUrl;
        this.userAgent = DEFAULT_USER_AGENT;
        this.readTimeout = DEFAULT_READ_TIMEOUT;
        this.connectTimeout = DEFAULT_CONNECT_TIMEOUT;
    }

    /**
     * Assert that the configuration is valid.
     */
    @Override
    public void assertValid() throws FgaInvalidParameterException {
        if (this.apiUrl == null) {
            throw new FgaInvalidParameterException(
                    "apiUrl", "Configuration", new NullPointerException("API URL cannot be null."));
        }

        URI uri;

        try {
            uri = URI.create(apiUrl);
            URL _url = uri.toURL();
        } catch (MalformedURLException | IllegalArgumentException cause) {
            throw new FgaInvalidParameterException("apiUrl", "Configuration", cause);
        }

        if (isNullOrWhitespace(uri.getScheme())) {
            throw new FgaInvalidParameterException("scheme", "Configuration");
        }

        if (isNullOrWhitespace(uri.getHost())) {
            throw new FgaInvalidParameterException("hostname", "Configuration");
        }
    }

    /**
     * Set the API URL for the http client.
     *
     * @param apiUrl The URL.
     * @return This object.
     */
    public BaseConfiguration apiUrl(String apiUrl) {
        this.apiUrl = apiUrl;
        return this;
    }

    /**
     * Get the API URL that was set.
     *
     * @return The url.
     */
    @Override
    public String getApiUrl() {
        return apiUrl;
    }

    /**
     * Set the user agent.
     *
     * @param userAgent The user agent.
     * @return This object.
     */
    public BaseConfiguration userAgent(String userAgent) {
        this.userAgent = userAgent;
        return this;
    }

    /**
     * Get the user agent.
     *
     * @return The user agent.
     */
    @Override
    public String getUserAgent() {
        return userAgent;
    }

    /**
     * Set the read timeout for the http client.
     *
     * <p>This is the value used by default for each request, though it can be
     * overridden on a per-request basis with a request interceptor.</p>
     *
     * @param readTimeout The read timeout used by default by the http client.
     *                    Setting this value to null resets the timeout to an
     *                    effectively infinite value.
     * @return This object.
     */
    public BaseConfiguration readTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
        return this;
    }

    /**
     * Get the read timeout that was set.
     *
     * @return The read timeout, or null if no timeout was set. Null represents
     * an infinite wait time.
     */
    @Override
    public Duration getReadTimeout() {
        return readTimeout;
    }

    /**
     * Sets the connect timeout (in milliseconds) for the http client.
     *
     * <p> In the case where a new connection needs to be established, if
     * the connection cannot be established within the given {@code
     * duration}, then {@link HttpClient#send(HttpRequest, BodyHandler)
     * HttpClient::send} throws an {@link HttpConnectTimeoutException}, or
     * {@link HttpClient#sendAsync(HttpRequest, BodyHandler)
     * HttpClient::sendAsync} completes exceptionally with an
     * {@code HttpConnectTimeoutException}. If a new connection does not
     * need to be established, for example if a connection can be reused
     * from a previous request, then this timeout duration has no effect.
     *
     * @param connectTimeout connection timeout in milliseconds
     * @return This object.
     */
    public BaseConfiguration connectTimeout(Duration connectTimeout) {
        this.connectTimeout = connectTimeout;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    @Override
    public Duration getConnectTimeout() {
        return connectTimeout;
    }
}
